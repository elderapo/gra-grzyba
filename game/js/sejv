var Key = {
	_pressed: {},

	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	SPACE2: 191,

	W: 87,
	S: 83,
	A: 65,
	D: 68,
	SPACE: 32,

	isDown: function(keyCode) {
		return this._pressed[keyCode];
	},

	onKeydown: function(event) {
		this._pressed[event.keyCode] = true;
	},

	onKeyup: function(event) {
		delete this._pressed[event.keyCode];
	}
};


var Game = {
	debug: true,
	fps: 100,
	tps: 50,
	width: 800,
	height: 500
};

Game.start = function() {
	this.canvas = document.createElement("canvas");
	this.canvas.width = this.width;
	this.canvas.height = this.height;

	this.context = this.canvas.getContext("2d");

	document.body.appendChild(this.canvas);

	this.player = new Player();
	this.player.add(400, 500, {UP: Key.W, DOWN: Key.S, LEFT: Key.A, RIGHT: Key.D, JUMP: Key.SPACE});
	this.player.add(400, 500, {UP: Key.UP, DOWN: Key.DOWN, LEFT: Key.LEFT, RIGHT: Key.RIGHT, JUMP: Key.SPACE2});

	this.platform = new Platform();
	this.platform.add(450, 10, 300);
	this.platform.add(400, 500, 100);
	this.platform.add(450, 500, 100);
	this.platform.add(200, 200, 300, {from: 100, to: 300, dir: "right", speed: "slow"});
	this.platform.add(350, 20, 200, true);

	Game.hookControls();

	setInterval(this.update, 1000 / this.tps);
	setInterval(this.draw, 1000 / this.fps);
};

Game.hookControls = function() {
	window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
	window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);
};

Game.draw = function() {
	Game.context.clearRect(0, 0, Game.width, Game.height);
	Game.platform.draw(Game.context);
	Game.player.draw(Game.context);
};

Game.update = function() {
	Game.player.update();
	Game.player.control();
	Game.platform.update();
};


function Player() {
	this.players = [];
};

Player.prototype.getAll = function() {
	return this.players;
};

Player.prototype.add = function(_x, _y, _keys) {

	this.player = {
		height: 70, // potem to trzeba wyciagac ze spritow jakos xD
		width: 40,  // to tez xD
		x: _x, // narazie ustawione na pa≈Çe ;s
		y: _y, // tak samo tutaj
		isJumping: false,
		jumpVelocity: 0,
		jumpVelocityDefault: -9,
		gravity: 0.5,
		foot: {},
		ignorePlatforms: false,
		falling: 4,
		currentPlatformY: 0,
		keys: _keys
	}

	this.players.push(this.player);
};

Player.prototype.delete = function(_index) {
	delete this.players[_index];
};

Player.prototype.update = function() {
	this.players.filter(function( obj ) {
		if (obj.isJumping) {
			obj.jumpVelocity += obj.gravity;
			obj.y += obj.jumpVelocity;

			if (obj.y <= 0) {
				obj.y = 0;
				obj.jumpVelocity = 0;
			} else if (obj.y >= Game.height-obj.height) {
				obj.y = Game.height-obj.height;
				obj.jumpVelocity = 0;
				obj.isJumping = false;
				obj.ignorePlatforms = false;
			}
		}

		obj.foot = {
			x: obj.x + (0.5 * obj.width),
			y: obj.y + obj.height
		}

	
		var platforms = Game.platform.getAll();

		obj.falling = 0;
		for (var i = 0; i <= platforms.length-1; i++) {
			// stawanie na platformie
			if (obj.foot.x > platforms[i].x & obj.foot.x < platforms[i].x + platforms[i].length & obj.isJumping == true & obj.jumpVelocity > 0 & obj.foot.y >= platforms[i].y & obj.foot.y <= platforms[i].y + 5 & obj.ignorePlatforms == false) {
				obj.isJumping = false;
				obj.jumpVelocity = 0;
				obj.y = platforms[i].y - obj.height;
				console.log("aaa");
			}

			// spadanie po zejsciu z platform
			if (!(obj.foot.x > platforms[i].x & obj.foot.x < platforms[i].x + platforms[i].length & obj.foot.y >= platforms[i].y & obj.foot.y <= platforms[i].y + 5)) {
				obj.falling++;

			}

		}

		if (obj.foot.y!= Game.height & obj.falling >= platforms.length) {
			obj.isJumping = true;
		}
	});
	
};

Player.prototype.draw = function(context) {
	this.players.filter(function( obj ) {
		if (Game.debug == true) {
			if (obj.isJumping == true) { context.strokeStyle = "green" } else { context.strokeStyle = "red" };

			context.lineWidth = 2;
			context.strokeRect(obj.x, obj.y, obj.width, obj.height);
			context.strokeRect(obj.x + (0.5 * obj.width)-1, obj.y + obj.height-7, 2, 5);
			context.font = "10px sans-serif";
			context.fillText("x: " + obj.foot.x, obj.x+2, obj.y+10);
			context.fillText("y: " + obj.foot.y, obj.x+2, obj.y+20);
		}
	});
};

Player.prototype.control = function() {
	this.players.filter(function( obj ) {

		if (Key.isDown(obj.keys.LEFT) & Key.isDown(obj.keys.RIGHT)) {
			obj.isMoving = false;
		} else {

			if (Key.isDown(obj.keys.UP)) {
				if (obj.isJumping == false) {
			        obj.jumpVelocity = obj.jumpVelocityDefault;
			        obj.isJumping = true;
		    	}
			}

			if (Key.isDown(obj.keys.LEFT)) {
				if (obj.x >= 5) {
					obj.x += -2;
				}
			}

			if (Key.isDown(obj.keys.RIGHT)) {
				if (obj.x < Game.width-obj.width-5) {
					obj.x += 2;
				}
			}

			if (Key.isDown(obj.keys.DOWN)) {
				if (obj.ignorePlatforms == false) {
					obj.ignorePlatforms = true;

		    	}
			}

			if (!Key.isDown(obj.keys.DOWN)) {
				if (obj.ignorePlatforms == true) {
					obj.ignorePlatforms = false;

		    	}
			}

			if (Key.isDown(obj.keys.JUMP)) {
				console.log('not programed yet Kappa');
				obj.jumpVelocity = 0;
				obj.isJumping = false;
			}

		}
	});
};

function Platform() {
	this.platforms = [];
};

Platform.prototype.getAll = function() {
	return this.platforms;
};

Platform.prototype.add = function(_y, _x, _length, _move) {
	this.platform = {
		y: _y,
		x: _x,
		length: _length,
		move: _move
	}
	this.platforms.push(this.platform);
};

Platform.prototype.deleteAll = function() {
	this.platforms = [];
};

Platform.prototype.update = function() {
	this.platforms.filter(function( obj ) {
		if (obj.move == true) {
			if (obj.x >= Game.width) {
				obj.x = -obj.length;
			}
			obj.x += 3;
			
		} else if (typeof obj.move === 'object') {
			var _platformSpeed = obj.move.speed;
			if (obj.move.speed == "fast") _platformSpeed = 8;
			if (obj.move.speed == "medium") _platformSpeed = 2;
			if (obj.move.speed == "slow") _platformSpeed = 1;

			if (obj.move.dir == "right") {
				obj.x += _platformSpeed;
				if (obj.move.to <= obj.x) {
					obj.move.dir = 1;
				}
			}

			if (obj.move.dir == "left") {
				obj.x += -_platformSpeed;
				if (obj.move.from >= obj.x) {
					obj.move.dir = 0;
				}
			}
		}
	});
};

Platform.prototype.draw = function(context) {
	this.platforms.filter(function( obj ) {
		Game.context.fillRect(obj.x, obj.y, obj.length, 5);
	});
};